{"version":3,"sources":["../src/utils/math.ts","../src/utils/dom.ts"],"sourcesContent":["/**\n * Represents a point in 2D space\n */\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * Unified rectangle representation\n */\nexport interface Rect {\n  left: number;\n  top: number;\n  right: number;\n  bottom: number;\n}\n\n// ========================\n// Basic Math Operations\n// ========================\n\nexport const sum = (a: number, b: number): number => a + b;\n\nexport const average = (numbers: number[]): number => {\n  return numbers.reduce((a, b) => a + b, 0) / numbers.length;\n};\n\nexport const roundNearest = (value: number, nearest: number): number =>\n  Math.round(value / nearest) * nearest;\n\n// ========================\n// Linear Operations\n// ========================\n\nexport const linearScale = (\n  value: number,\n  inMin: number,\n  inMax: number,\n  outMin: number,\n  outMax: number\n): number => ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;\n\nexport const normalizeRatio = (\n  value: number,\n  min: number,\n  max: number\n): number => (value - min) / (max - min);\n\nexport const lerp = (a: number, b: number, amount: number): number =>\n  (1 - amount) * a + amount * b;\n\n// ========================\n// Point Operations\n// ========================\n\nexport const midpoint = (\n  a: Point | [number, number],\n  b: Point | [number, number]\n): [number, number] => {\n  const p1 = Array.isArray(a) ? { x: a[0], y: a[1] } : a;\n  const p2 = Array.isArray(b) ? { x: b[0], y: b[1] } : b;\n  return [(p1.x + p2.x) / 2, (p1.y + p2.y) / 2];\n};\n\nexport const distance = (p1: Point, p2: Point): number =>\n  Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n\n// ========================\n// Rectangle Operations\n// ========================\n\n/**\n * Creates Rect from corner points\n */\nexport const createRect = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n): Rect => ({\n  left: Math.min(x1, x2),\n  top: Math.min(y1, y2),\n  right: Math.max(x1, x2),\n  bottom: Math.max(y1, y2),\n});\n\n/**\n * Checks if two rectangles overlap\n */\nexport const overlaps = (a: Rect, b: Rect): boolean =>\n  a.left < b.right && b.left < a.right && a.top < b.bottom && b.top < a.bottom;\n\n/**\n * Checks if rectangle A contains rectangle B\n */\nexport const contains = (a: Rect, b: Rect): boolean =>\n  a.left <= b.left &&\n  a.top <= b.top &&\n  a.right >= b.right &&\n  a.bottom >= b.bottom;\n\n/**\n * Checks if point is inside rectangle\n */\nexport const isInside = (point: Point, rect: Rect): boolean =>\n  point.x > rect.left &&\n  point.x < rect.right &&\n  point.y > rect.top &&\n  point.y < rect.bottom;\n\n/**\n * Compares two rectangles for equality\n */\nexport const rectsEqual = (a: Rect, b: Rect): boolean =>\n  a.left === b.left &&\n  a.top === b.top &&\n  a.right === b.right &&\n  a.bottom === b.bottom;\n\n// ========================\n// Angle Operations\n// ========================\n\nexport const radsToDegs = (rad: number): number => (rad * 180) / Math.PI;\n\nexport const degsToRads = (deg: number): number => (deg * Math.PI) / 180.0;\n\nexport const radiansAngle = (p1: Point, p2: Point): number =>\n  Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\nexport const degreesAngle = (p1: Point, p2: Point): number =>\n  radsToDegs(radiansAngle(p1, p2));\n","import { Point, Rect, midpoint, overlaps, contains, rectsEqual } from \"./math\";\n\n/**\n * Converts DOMRect to Rect interface\n */\nconst domRectToRect = (rect: DOMRect): Rect => ({\n  left: rect.left,\n  top: rect.top,\n  right: rect.right,\n  bottom: rect.bottom,\n});\n\nexport class DomElement {\n  private ele: HTMLElement;\n\n  constructor(element: HTMLElement | string) {\n    if (typeof element === \"string\") {\n      const el = document.querySelector<HTMLElement>(element);\n      if (!el) throw new Error(`Element not found: ${element}`);\n      this.ele = el;\n    } else {\n      this.ele = element;\n    }\n  }\n\n  hasOverflow() {\n    return (\n      this.ele.scrollHeight > this.ele.clientHeight ||\n      this.ele.scrollWidth > this.ele.clientWidth\n    );\n  }\n\n  hasCssOverflow() {\n    return [\"auto\", \"scroll\"].includes(\n      window.getComputedStyle(this.ele).overflow\n    );\n  }\n\n  get rect(): Rect {\n    return domRectToRect(this.ele.getBoundingClientRect());\n  }\n\n  intersect(other: DomElement) {\n    return overlaps(this.rect, other.rect);\n  }\n\n  isContainedIn(container: DomElement) {\n    return contains(container.rect, this.rect);\n  }\n\n  compareRects(other: DomElement) {\n    return rectsEqual(this.rect, other.rect);\n  }\n\n  getCenter(): Point {\n    const rect = this.rect;\n    const [x, y] = midpoint(\n      { x: rect.left, y: rect.top },\n      { x: rect.right, y: rect.bottom }\n    );\n    return { x, y };\n  }\n}\n\nexport const getDistanceToBottom = (): number =>\n  document.body.scrollHeight - window.innerHeight - window.scrollY;\n"],"mappings":"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","names":["sum","a","b","average","numbers","roundNearest","value","nearest","linearScale","inMin","inMax","outMin","outMax","normalizeRatio","min","max","lerp","amount","midpoint","p1","p2","distance","createRect","x1","y1","x2","y2","overlaps","contains","isInside","point","rect","rectsEqual","radsToDegs","rad","degsToRads","deg","radiansAngle","degreesAngle","domRectToRect","rect","DomElement","element","el","other","overlaps","container","contains","rectsEqual","x","y","midpoint","getDistanceToBottom"]}