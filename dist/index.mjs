var x=(e,r)=>e+r,b=e=>e.reduce((r,n)=>r+n,0)/e.length,s=(e,r)=>Math.round(e/r)*r,y=(e,r,n,t,o)=>(e-r)*(o-t)/(n-r)+t,c=(e,r,n)=>(e-r)/(n-r),a=(e,r,n)=>(1-n)*e+n*r,i=(e,r)=>{let n=Array.isArray(e)?{x:e[0],y:e[1]}:e,t=Array.isArray(r)?{x:r[0],y:r[1]}:r;return[(n.x+t.x)/2,(n.y+t.y)/2]},p=(e,r)=>Math.sqrt(Math.pow(r.x-e.x,2)+Math.pow(r.y-e.y,2)),P=(e,r)=>e.x>r.x1&&e.x<r.x2&&e.y>r.y1&&e.y<r.y2,u=e=>e*180/Math.PI,d=e=>e*Math.PI/180,m=(e,r)=>Math.atan2(r.y-e.y,r.x-e.x),l=(e,r)=>u(m(e,r)),h=(e,r)=>e.x1<r.x2&&r.x1<e.x2&&e.y1<r.y2&&r.y1<e.y2,R=(e,r)=>e.x1<=r.x1&&e.y1<=r.y1&&e.x2>=r.x2&&e.y2>=r.y2;export{b as average,R as contains,l as degreesAngle,d as degsToRads,p as distance,P as isInside,a as lerp,y as linearScale,i as midpoint,c as normalizeRatio,h as overlaps,m as radiansAngle,u as radsToDegs,s as roundNearest,x as sum};
//# sourceMappingURL=index.mjs.map